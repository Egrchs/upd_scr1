# Сводный отчет по разработке и тестированию MIPS-to-RISC-V транслятора

## 1. Описание транслятора MIPS-to-RISC-V (`mips_to_riscv_translator_fixed.sv`)

Транслятор предназначен для преобразования инструкций архитектуры MIPS32 в эквивалентные инструкции архитектуры RISC-V (RV32I).

**Поддерживаемые MIPS инструкции и их трансляция:**

*   **Арифметико-логические R-типа:**
    *   `ADDU rd, rs, rt` -> `ADD rd, rs, rt` (RISC-V)
    *   `SUBU rd, rs, rt` -> `SUB rd, rs, rt` (RISC-V)
    *   `SLTU rd, rs, rt` -> `SLTU rd, rs, rt` (RISC-V)
    *   `OR rd, rs, rt`   -> `OR rd, rs, rt` (RISC-V)
    *   `SLL rd, rt, shamt` -> `SLLI rd, rt, shamt` (RISC-V) (при `rs=0` в MIPS)
*   **Арифметико-логические I-типа:**
    *   `ADDIU rt, rs, imm` -> `ADDI rt, rs, imm` (RISC-V)
    *   `LUI rt, imm`       -> `LUI rt, imm_adjusted` (RISC-V, imm корректируется для 20-битного поля)
    *   `ORI rt, rs, imm`   -> `ORI rt, rs, imm` (RISC-V, с проверкой что старшие биты MIPS immediate равны 0)
*   **Инструкции загрузки/сохранения:**
    *   `SW rt, offset(rs)` -> `SW rt, offset(rs)` (RISC-V, поля смещения переформатируются)
*   **Инструкции ветвления и переходов:**
    *   `BEQ rs, rt, offset` -> `BEQ rs, rt, offset_adjusted` (RISC-V, смещение корректируется)
    *   `BNE rs, rt, offset` -> `BNE rs, rt, offset_adjusted` (RISC-V, смещение корректируется)
    *   `JR rs`              -> `JALR x0, rs, 0` (RISC-V)
*   **NOP (реализация через SLL):**
    *   `SLL $zero, $zero, 0` (MIPS NOP) -> `ADDI x0, x0, 0` (RISC-V NOP, по умолчанию) или `SLLI x0, x0, 0`.

**Ключевые особенности и реализованные оптимизации:**

*   **Peephole-оптимизация LUI+ORI:**
    *   Распознает последовательность MIPS `LUI rt, imm_H` + `ORI rt, rt, imm_L`.
    *   Транслирует ее в оптимизированную пару RISC-V: `LUI rt, riscv_imm_H` + `ADDI rt, rt, riscv_imm_L`.
    *   Это позволяет эффективно формировать 32-битные константы в RISC-V.
*   **Обработка слотов задержки (Delay Slots):**
    *   Конечный автомат (FSM) транслятора корректно обрабатывает инструкции в слотах задержки для ветвлений (`BEQ`, `BNE`) и переходов (`JR`). Инструкция из слота задержки выдается перед инструкцией ветвления/перехода.
*   **Конечный автомат (FSM):**
    *   Используется FSM для управления процессом трансляции, включая ожидание второй инструкции для peephole-оптимизации и обработку инструкций из слота задержки.
    *   Состояния FSM включают `IDLE`, `AWAIT_ORI`, `OUTPUT_SINGLE`, `OUTPUT_OPT_LUI`, `OUTPUT_OPT_ADDI`, `WAIT_DELAY_SLOT`, `OUTPUT_SLOT`, `OUTPUT_BRANCH`, `OUTPUT_STASHED_LUI`.
*   **Обработка ошибок:**
    *   Транслятор может помечать выходную RISC-V инструкцию как ошибочную (`riscv_instr_error`), если исходная MIPS инструкция не поддерживается или содержит некорректные параметры (например, в `ORI` старшие биты immediate не нулевые).
    *   Принимает на вход флаг ошибки от предыдущей стадии (`mips_instr_error`).

**Архитектура транслятора:**

*   Модуль `mips_to_riscv_translator_fixed` имеет стандартные интерфейсы для тактового сигнала, сброса, входной MIPS инструкции (с флагами валидности и ошибки) и выходной RISC-V инструкции (с флагами валидности и ошибки), а также сигналы квитирования (`translator_ready`, `riscv_instr_accepted`).
*   Используются структуры `mips_i_type_t` и `mips_r_type_t` для разбора полей MIPS инструкций.
*   Основная логика трансляции реализована в комбинационной функции `translate_instruction` и `translate_lui_ori_pair`.

**Плюсы:**

*   Реализована важная peephole-оптимизация для `LUI+ORI`.
*   Корректная обработка инструкций в слотах задержки.
*   Поддержка основного набора целочисленных инструкций MIPS.
*   Модульная структура с четким FSM.

**Минусы и возможные улучшения:**

*   **Ограниченный набор инструкций:** Транслятор поддерживает не все инструкции MIPS (например, отсутствуют другие инструкции R-типа, более сложные ветвления, инструкции сопроцессора, операции с плавающей точкой).
*   **Трансляция ORI:** При трансляции одиночной `ORI` предполагается, что старшие 4 бита 16-битного непосредственного значения MIPS равны нулю, иначе выдается ошибка. Это ограничение можно снять, если использовать несколько RISC-V инструкций для формирования полного 16-битного значения перед операцией ORI, но это усложнит трансляцию.
*   **Эффективность для некоторых инструкций:** Некоторые трансляции могут быть не самыми оптимальными с точки зрения количества RISC-V инструкций или производительности (хотя для поддерживаемого набора это в основном 1-в-1 или 2-в-2 для LUI+ORI).
*   **Отсутствие поддержки исключений MIPS:** Транслятор не эмулирует специфические исключения MIPS (например, `syscall`, `break`, `trap`). Он полагается на то, что ядро RISC-V обработает нелегальные инструкции или сгенерирует свои исключения.
*   **Отсутствие поддержки пользовательского и системного режимов MIPS:** Трансляция ориентирована на выполнение кода в одном привилегированном режиме.

## 2. Описание ассемблерного теста (`final_final_test.s`)

Тест предназначен для проверки корректности работы транслятора и базовой функциональности RISC-V ядра (SCR1) после трансляции.

**Структура теста:**

Тест разделен на несколько логических блоков:

*   **Блок 0: Инициализация:**
    *   `addiu $s0, $zero, 0x400`: Загрузка адреса `0x400` в `$s0` для статуса основного теста.
    *   `addiu $s2, $zero, 0x404`: Загрузка адреса `0x404` в `$s2` для статуса арифметического теста.
*   **Блок А: Основной тест (проверка сравнения):**
    *   Инициализируются регистры `$t0`, `$t1`, `$t5` значением 42.
    *   Проверяется равенство `$t1 == $t5` с помощью инструкций `SLTU` и `OR`.
    *   Результат (0 для PASS, >0 для FAIL) сохраняется в `$a2`.
    *   `sw $a2, 0($s0)`: Результат записывается в `Memory[0x400]`. Ожидаемое значение: 0.
*   **Блок Б: Арифметический тест:**
    *   Цель: проверить, что `123 + 77 - 77 = 123`.
    *   Используются инструкции `ADDIU`, `ADDU`, `SUBU`.
    *   Промежуточные значения сохраняются в регистрах `$t3, $t4, $t5, $s1`.
    *   Результат проверки (`$s1 == $t3`) сохраняется в `$a3` (0 для PASS).
    *   `sw $a3, 0($s2)`: Результат записывается в `Memory[0x404]`. Ожидаемое значение: 0.
*   **Блок В: Тест peephole-оптимизации LUI+ORI:**
    *   `lui $t6, 0xDEAD`
    *   `ori $t6, $t6, 0xBEEF`
    *   Цель: загрузить константу `0xDEADBEEF` в регистр `$t6`. Транслятор должен оптимизировать эту пару.
*   **Блок Г: Завершение:**
    *   `addiu $t2, $zero, 0`: Обнуление MIPS `$t2` (который транслируется в RISC-V `x10`). Это необходимо для удовлетворения условия PASS тестбенча SCR1, который проверяет `x10 == 0` на выходе.
    *   `addiu $t7, $zero, 0xF8`: Загрузка адреса завершения (`SCR1_SIM_EXIT_ADDR`) в `$t7`.
    *   `jr $t7`: Переход на адрес завершения.
    *   `nop`: Инструкция в слоте задержки.

**Что проверяет тест:**

*   **Корректность трансляции:** Всего набора инструкций, используемых в тесте (`ADDIU`, `ADDU`, `SUBU`, `ORI`, `SLTU`, `OR`, `SW`, `LUI`, `JR`, `NOP`).
*   **Корректность peephole-оптимизации `LUI+ORI`**.
*   **Базовую функциональность АЛУ ядра RISC-V:** Сложение, вычитание, логические операции, сравнение.
*   **Операции загрузки непосредственных значений** (`ADDIU`, `LUI`, `ORI`).
*   **Операции записи в память** (`SW`).
*   **Операции безусловного перехода** (`JR`) и обработку слота задержки.
*   **Соответствие условиям завершения тестбенча SCR1** (PC на выходе и значение регистра `x10`).

**Что НЕ проверяет тест (или проверяет ограниченно):**

*   **Все возможные инструкции MIPS:** Набор инструкций в тесте ограничен.
*   **Корректность всех полей инструкций:** Тест использует конкретные операнды, не покрывая все возможные значения.
*   **Переполнения в арифметических операциях:** `ADDU`, `SUBU` не генерируют исключений по переполнению; тест не проверяет флаги или поведение при переполнении для знаковых операций.
*   **Инструкции ветвления с условием (`BEQ`, `BNE`):** В данном тесте они не используются.
*   **Инструкции чтения из памяти (`LW`, `LH`, `LB`, etc.).**
*   **Исключения:** Тест не нацелен на генерацию или проверку обработки исключений (кроме неявной проверки, что не возникает неожиданных исключений).
*   **Взаимодействие с CSR (Control and Status Registers),** кроме неявного влияния на поток выполнения (например, при обработке исключений, если бы они были).
*   **Сложные сценарии с зависимостями по данным или управляющим потоком,** которые могли бы выявить проблемы в конвейере ядра.
*   **Влияние кэшей** (если они есть в системе).

## 3. Ожидаемые значения в регистрах и памяти (`final_final_test.s`)

Ниже приведены ожидаемые десятичные значения в ключевых регистрах RISC-V (в массиве `mprf_int` симулятора, где `mprf_int[N]` соответствует `xN`) и ячейках памяти после выполнения соответствующих блоков кода.

**Соглашения по отображению MIPS регистров на RISC-V (по номеру):**
*   `$s0`(16)->`x16` | `$s1`(17)->`x17` | `$s2`(18)->`x18`
*   `$a2`(6)->`x6`   | `$a3`(7)->`x7`
*   `$t0`(8)->`x8`   | `$t1`(9)->`x9`   | `$t2`(10)->`x10` | `$t3`(11)->`x11`
*   `$t4`(12)->`x12` | `$t5`(13)->`x13` | `$t6`(14)->`x14` | `$t7`(15)->`x15`
*   `$k0`(26)->`x26` | `$k1`(27)->`x27`

**Ожидаемые значения:**

1.  **После инициализации адресов:**
    *   `mprf_int[16]` (`x16`): **1024** (`0x400`)
    *   `mprf_int[18]` (`x18`): **1028** (`0x404`)

2.  **После Блока А (Основной тест):**
    *   `mprf_int[8]` (`x8`): **42**
    *   `mprf_int[9]` (`x9`): **42**
    *   `mprf_int[13]` (`x13`): **42** (будет перезаписан в Блоке Б)
    *   `mprf_int[26]` (`x26`): **0**
    *   `mprf_int[27]` (`x27`): **0**
    *   `mprf_int[6]` (`x6`): **0**
    *   **Память `Memory[0x400]`**: `0` (десятичное)

3.  **После Блока Б (Арифметический тест):**
    *   `mprf_int[11]` (`x11`): **123**
    *   `mprf_int[12]` (`x12`): **77**
    *   `mprf_int[13]` (`x13`): **200** (перезаписывает значение из Блока А)
    *   `mprf_int[17]` (`x17`): **123**
    *   `mprf_int[26]` (`x26`): **0** (значение из Блока А перезаписано)
    *   `mprf_int[27]` (`x27`): **0** (значение из Блока А перезаписано)
    *   `mprf_int[7]` (`x7`): **0**
    *   **Память `Memory[0x404]`**: `0` (десятичное)

4.  **После Блока В (Тест LUI+ORI):**
    *   `mprf_int[14]` (`x14`, MIPS `$t6`): **3735928559** (`0xDEADBEEF`)

5.  **После Блока Г (Завершение, на момент проверки тестбенчем при `PC = 0xF8`):**
    *   `mprf_int[10]` (`x10`, MIPS `$t2`): **0** (ключевое условие для PASS тестбенча)
    *   `mprf_int[15]` (`x15`, MIPS `$t7`): **248** (`0xF8`)
    *   Остальные регистры сохраняют свои значения из предыдущих блоков (например, `x16=1024`, `x8=42`, `x11=123`, `x14=3735928559` и т.д.).

Эти значения следует проверять на waveform для подтверждения корректной работы транслятора и ядра.