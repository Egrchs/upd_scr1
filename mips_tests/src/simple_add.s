# ======================================================================
# Файл: src/final_test.s
# ФИНАЛЬНАЯ РАБОЧАЯ ВЕРСИЯ (ИСПРАВЛЕННАЯ)
# Адаптирована для работы с комбинационным транслятором.
# Добавлен корректный бесконечный цикл для завершения теста.
# ======================================================================

.set   noreorder         # Запрещаем ассемблеру переставлять инструкции
.text                      # Начало секции кода

# ----------------------------------------------------------------------
# Размещаем NOP точно по адресу 0x1FC (физический адрес сброса)
# ----------------------------------------------------------------------
.org 0x1FC
_start_physical:           # Физическая точка входа для линкера
    nop                    # sll $zero, $zero, 0 (код 0x00000000)

# ----------------------------------------------------------------------
# Размещаем основной код точно по адресу 0x200
# ----------------------------------------------------------------------
.org 0x200
_start:                    # Логическая точка входа, откуда начнет ядро

    ### 1. Подготовка адреса для записи результата ###
    # Загружаем адрес 0x400 в регистр $s0.
    # Используем ADDIU, так как его 16-битное знаковое поле
    # напрямую транслируется в 12-битное поле ADDI в RISC-V.
    # $s0 (x16) = $zero + 1024
    addiu $s0, $zero, 0x400

    ### 2. Тело теста ###
    ori  $t0, $zero, 42    # $t0 (x8) = 42
    addu $t1, $t0, $zero  # $t1 (x9) = 42

    ### 3. Проверка и формирование статуса ###
    ori  $t5, $zero, 42    # Ожидаемый результат
    
    # $a2 будет 0, если $t1 == $t5. Иначе 1.
    # Это стандартный способ проверки на равенство с помощью sltu.
    sltu $a0, $t1, $t5      # a0 = ($t1 < $t5) ? 1 : 0
    sltu $a1, $t5, $t1      # a1 = ($t5 < $t1) ? 1 : 0
    or   $a2, $a0, $a1      # a2 = a0 | a1. Если a2=0, значит числа равны.

    ### 4. Запись результата в память ###
    # Записываем по адресу, который мы сформировали в шаге 1 (0x400)
    sw   $a2, 0($s0)       # Memory[0x400] = статус (0 для PASS, >0 для FAIL)

    ### 5. Остановка ###
    # Бесконечный цикл, чтобы остановить выполнение и ждать,
    # пока Testbench обнаружит результат. Это стандартная практика
    # для bare-metal тестов.
loop:
    beq $zero, $zero, loop # Безусловный переход на самого себя.
    nop                    # Эта инструкция находится в "слоте задержки" (delay slot)
                           # и выполнится один раз перед самим переходом.