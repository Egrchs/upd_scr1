# ======================================================================
# Файл: src/final_test.s
# ФИНАЛЬНАЯ РАБОЧАЯ ВЕРСИЯ
# Адаптирована для работы с комбинационным транслятором.
# ======================================================================

.set   noreorder         # Запрещаем ассемблеру переставлять инструкции
.text                      # Начало секции кода

# ----------------------------------------------------------------------
# Размещаем NOP точно по адресу 0x1FC
# ----------------------------------------------------------------------
.org 0x1FC
_start_physical:           # Физическая точка входа для линкера
    nop                    # sll $zero, $zero, 0 (код 0x00000000)

# ----------------------------------------------------------------------
# Размещаем основной код точно по адресу 0x200
# ----------------------------------------------------------------------
.org 0x200
_start:                    # Логическая точка входа, откуда начнет ядро

    ### 1. Подготовка адреса для записи результата ###
    # ИСПРАВЛЕНИЕ: Вместо lui/ori используем addiu с константой,
    # которая помещается в 12-битное поле RISC-V ADDI.
    # Это позволяет избежать ошибки трансляции и бесконечного цикла.
    # $s0 (x16) = $zero + 1024
    addiu $s0, $zero, 0x400

    ### 2. Тело теста ###
    ori  $t0, $zero, 42    # $t0 (x8) = 42
    addu $t1, $t0, $zero  # $t1 (x9) = 42

    ### 3. Проверка и формирование статуса ###
    ori  $t5, $zero, 42    # Ожидаемый результат
    
    # $a2 будет 0, если $t1 == $t5. Иначе 1.
    sltu $a0, $t1, $t5
    sltu $a1, $t5, $t1
    or   $a2, $a0, $a1

    ### 4. Запись результата в память ###
    # Записываем по адресу, который мы сформировали в шаге 1 (0x400)
    sw   $a2, 0($s0)       # Memory[0x400] = статус (0 для PASS)

    ### 5. Остановка ###
    # Бесконечный цикл, чтобы показать успешное завершение.
    # Testbench должен остановить симуляцию по записи в память,
    # но это хорошая практика.
loop:
    nop
    nop
    # В реальной системе здесь был бы 'j loop' или 'beq $zero, $zero, loop'